// js/script.js

// Import functions from our modules
import { readJobs } from './jobManager.js';
import { run as runScheduler } from './scheduler.js';

// Import rendering and calculation functions
import { renderGanttChart } from './ganttRenderer.js';
import { calculateAndDisplayMetrics } from './metricsCalculator.js';


// --- Global State Variables ---
let selectedAlgorithm = null; // To store the name of the currently selected algorithm
let jobData = []; // To store the job data read from the table before scheduling
let currentSchedule = null; // To store the schedule generated by the scheduler


// Store references to text elements that need color changes
// This array will be populated after the DOM is loaded
const textElementsToColor = [];

// Mapping Algorithm names to colors (using colors from your mini-bars CSS in selector.css)
const algorithmColors = {
    'FCFS': '#2e86de', // Blue
    'SJF': '#e74c3c',  // Red
    'NPP': '#f1c40f',  // Yellow
    'PP': '#27ae60'   // Green
};


// Wait for the DOM to be fully loaded before attaching event listeners
document.addEventListener('DOMContentLoaded', () => {

    // --- Get DOM References ---
    const body = document.body; // Get a reference to the body element
    const jobTableBody = document.getElementById('job-table-body');
    const numJobsInput = document.getElementById('num-jobs');
    const executeButton = document.getElementById('execute-btn');
    const refreshButton = document.getElementById('refresh-btn');
    const helpButton = document.getElementById('help-btn');
    const algoButtons = document.querySelectorAll('.selector-content .algo-btn');

    // Get references to display areas for clearing
    const ganttChartBar = document.querySelector('.gantt-chart-bar');
    const timelineBar = document.querySelector('.timeline-bar');
    const ttSectionValues = document.querySelector('.turnaround-time-section .metric-values');
    const ttAverage = document.getElementById('tt-average');
    const wtSectionValues = document.querySelector('.waiting-time-section .metric-values');
    const wtAverage = document.getElementById('wt-average');
    const cpuUtilizationBar = document.querySelector('.cpu-utilization-bar');
    const cpuUtilizationPercentage = document.getElementById('cpu-utilization-percentage');
    const cpuUtilizationComputation = document.getElementById('cpu-utilization-computation'); // Assuming you have this element


    // Populate the array of text elements to color AFTER DOM is loaded
    // Select specific labels and table headers
    const ganttChartLabel = document.querySelector('.gantt-chart-label');
    const turnaroundTimeLabel = document.querySelector('.turnaround-time-section .metric-label');
    const waitingTimeLabel = document.querySelector('.waiting-time-section .metric-label');
    const timelineLabel = document.querySelector('.timeline-label');
    const cpuUtilizationLabel = document.querySelector('.cpu-utilization-section .metric-label');
    // Select all table header cells (th) within the job input section's table head
    const jobTableLabels = document.querySelectorAll('.job-input-section thead th');


    // Add found elements to the array (check if they exist in case of typos or structure changes)
    if (ganttChartLabel) textElementsToColor.push(ganttChartLabel);
    if (turnaroundTimeLabel) textElementsToColor.push(turnaroundTimeLabel);
    if (waitingTimeLabel) textElementsToColor.push(waitingTimeLabel);
    if (timelineLabel) textElementsToColor.push(timelineLabel);
    if (cpuUtilizationLabel) textElementsToColor.push(cpuUtilizationLabel);
    // Add all selected table headers to the array
    jobTableLabels.forEach(label => textElementsToColor.push(label));

    // Also include the average/percentage spans and the computation text
    if (ttAverage) textElementsToColor.push(ttAverage);
    if (wtAverage) textElementsToColor.push(wtAverage);
    if (cpuUtilizationPercentage) textElementsToColor.push(cpuUtilizationPercentage);
    if (cpuUtilizationComputation) textElementsToColor.push(cpuUtilizationComputation); // Include computation element


    const defaultNumberOfJobs = 5;

    // --- Function to Render Job Table Rows ---
    function renderJobTable(numberOfJobs) {
        jobTableBody.innerHTML = '';
        jobData = []; // Clear jobData array when re-rendering table structure

        for (let i = 1; i <= numberOfJobs; i++) {
            const row = document.createElement('tr');
            row.setAttribute('data-job-index', i); // Add data attribute for potentially linking later

            // Add 'data-label' attributes or specific classes to the td elements if you want
            // to potentially color individual job details later, but for now the request
            // is for the header text (<th>) to change color.
            row.innerHTML = `
                <td>Job ${i}</td>
                <td><input type="number" class="job-at" value="0" min="0"></td>
                <td><input type="number" class="job-bt" value="10" min="1"></td>
                <td><input type="number" class="job-p" value="1" min="1"></td>
            `;
            jobTableBody.appendChild(row);
        }
    }

     // --- Initial Render of the Job Table based on input value ---
     const initialNumJobs = parseInt(numJobsInput.value, 10);
     renderJobTable(initialNumJobs);

     // Add event listener to the number of jobs input to update the table
     numJobsInput.addEventListener('change', (event) => {
         const newNumJobs = parseInt(event.target.value, 10);
         if (!isNaN(newNumJobs) && newNumJobs >= 1) {
             renderJobTable(newNumJobs);
         } else {
             // Optionally reset to default or show an error if input is invalid
             console.warn("Invalid number of jobs entered. Keeping previous value.");
             // Revert input value to the current number of rows
             event.target.value = jobTableBody.children.length;
         }
     });


    // --- Algorithm Selection Buttons ---
    algoButtons.forEach(button => {
        button.addEventListener('click', () => {
            // Get the algorithm name from the button's text content (e.g., "FCFS")
            const algorithmName = button.textContent;
            selectedAlgorithm = algorithmName;
            console.log(`Selected algorithm: ${selectedAlgorithm}`);

            // --- Update Button Styling ---
            // Remove 'selected-algo' class from all algorithm buttons
            algoButtons.forEach(btn => btn.classList.remove('selected-algo'));
            // Add 'selected-algo' class to the clicked button.
            // Your index.html already has some CSS for .selected-algo
            button.classList.add('selected-algo');

            // --- Apply Color Theme (Button, Text, and Body Background) ---
            applyAlgorithmColor(selectedAlgorithm);
        });
    });


    // --- Function to Apply Algorithm Colors ---
    function applyAlgorithmColor(algorithmName) {
        const color = algorithmColors[algorithmName];
        // Find the currently selected button by class (the one that was just clicked)
        const selectedButton = document.querySelector('.algo-btn.selected-algo');


        // --- Reset Colors for all Text Elements and Buttons ---
        // Reset all targeted text elements back to their default color (handled by CSS)
        // We don't need to loop through textElementsToColor to reset if CSS handles default
        // Just ensure the color is set correctly below for the selected theme.
         resetColors(); // Call the reset function to set default colors and body background


        // Remove inline background color from ALL algorithm buttons first
        // This ensures only the *selected* button gets the inline style applied next
        algoButtons.forEach(btn => {
            btn.style.backgroundColor = ''; // Resets to the color defined in selector.css
            btn.style.color = ''; // Resets text color
             // Handle NPP specific text color if it has a non-default color in selector.css
             if (btn.textContent === 'NPP') {
                 // Assuming NPP button has a specific default text color in selector.css (e.g., black)
                 // If not, this line might not be needed or needs adjustment.
                 // btn.style.color = 'black'; // Revert to its default text color from CSS
             }
        });


        if (!color) {
            console.warn(`Color not found for algorithm: ${algorithmName}`);
             // If color not found, button and text will just have their default styles
            return;
        }


        // --- Apply the selected algorithm's color ---

        // Apply the color to each targeted text element using inline styles
        // Using inline styles overrides CSS rules, ensuring the selected color is applied
        textElementsToColor.forEach(element => {
            if (element) { // Check if the element exists
                element.style.color = color;
            }
        });

        // Set the background color of the selected button using inline styles
        // This inline style overrides the default background color defined in selector.css
         if(selectedButton) {
               selectedButton.style.backgroundColor = color;
               // Set text color for readability against the new background
               // Check contrast or just set a standard readable color like white or black
               if (algorithmName === 'NPP') { // NPP background is yellow, needs black text
                    selectedButton.style.color = 'black';
               } else { // Other backgrounds are dark, needs white text
                   selectedButton.style.color = 'white';
               }
         }

        // --- Add the theme class to the body ---
        if (body) {
            // Remove any existing theme classes first
            body.classList.remove('theme-fcfs', 'theme-sjf', 'theme-npp', 'theme-pp');
            // Add the new theme class based on the algorithm name
            body.classList.add(`theme-${algorithmName.toLowerCase()}`);
        }
    }

     // --- Function to Reset All Colors to Default ---
     // This function is called before applying the new theme color and by the refresh button.
     function resetColors() {
         // Reset all targeted text elements back to their default color (handled by CSS)
         textElementsToColor.forEach(element => {
             if (element) {
                 element.style.color = ''; // Clear inline style, reverts to CSS color
             }
         });

         // Reset inline background color from ALL algorithm buttons
        algoButtons.forEach(btn => {
            btn.style.backgroundColor = ''; // Resets to the color defined in selector.css
            btn.style.color = ''; // Resets text color
             // Handle NPP specific text color if it has a non-default color in selector.css
             if (btn.textContent === 'NPP') {
                 // Assuming NPP button has a specific default text color in selector.css (e.g., black)
                 // If not, this line might not be needed or needs adjustment.
                 // btn.style.color = 'black'; // Revert to its default text color from CSS
             }
        });

         // --- Remove any theme classes from the body ---
          if (body) {
              body.classList.remove('theme-fcfs', 'theme-sjf', 'theme-npp', 'theme-pp');
              // The default background-color defined in the body {} rule in index.html
              // will automatically apply when theme classes are removed.
          }

          // Explicitly set default colors for average/percentage spans and computation text
          // These might need specific default colors different from the general labels
          // Re-setting these after clearing inline styles ensures they have a base color
           if(ttAverage) ttAverage.style.color = '#f1c40f'; // Example default highlight color
           if(wtAverage) wtAverage.style.color = '#f1c40f'; // Example default highlight color
           if(cpuUtilizationPercentage) cpuUtilizationPercentage.style.color = '#f1c40f'; // Example default highlight color
           if(cpuUtilizationComputation) cpuUtilizationComputation.style.color = 'white'; // Example default color
     }


    // --- Execute Button ---
    executeButton.addEventListener('click', () => {
        if (!selectedAlgorithm) {
            alert("Please select a scheduling algorithm first.");
            return;
        }

        const confirmExecute = confirm(`Are the table values final? (Algorithm: ${selectedAlgorithm})`);

        if (confirmExecute) {
            console.log("Executing simulation...");

            const currentJobData = readJobs(); // Call from jobManager.js

            if (!currentJobData || currentJobData.length === 0) {
                 if (!currentJobData) alert("Please correct the invalid job inputs before executing.");
                 else alert("No valid job data entered. Please add jobs.");
                 return;
            }

            jobData = currentJobData; // Store job data in the global state
            console.log("Job Data Read:", jobData);

            // Run the selected algorithm using scheduler
            const schedule = runScheduler(jobData, selectedAlgorithm);

            if (!schedule || schedule.length === 0) {
                console.error("Scheduler failed to produce a schedule or schedule is empty.");
                alert("An error occurred during scheduling or no jobs could be scheduled. Please check console for details.");
                return;
            }

            currentSchedule = schedule; // Store schedule in the global state
            console.log("Generated Schedule:", currentSchedule);

            // --- Render Gantt Chart & Timeline ---
             // The renderGanttChart function needs access to jobData (original jobs) and schedule
             renderGanttChart(currentSchedule, jobData);


            // --- Calculate & Display Metrics ---
             // The calculateAndDisplayMetrics function needs access to original jobData and schedule
             calculateAndDisplayMetrics(jobData, currentSchedule);

            console.log("Execution complete. Results displayed.");

        } else {
            console.log("Execution cancelled.");
        }
    });


    // --- Refresh Button ---
    refreshButton.addEventListener('click', () => {
        const confirmReset = confirm("This will reset the website, do you wish to proceed?");

        if (confirmReset) {
            // --- Reset UI Elements ---

            // Reset Number of Jobs input to its default value (5)
            numJobsInput.value = defaultNumberOfJobs;
            renderJobTable(defaultNumberOfJobs); // Re-render table with default jobs


            // Clear Gantt Chart
            if (ganttChartBar) {
                ganttChartBar.innerHTML = '';
                 ganttChartBar.style.width = ''; // Reset Gantt chart bar width inline style
            }

            // Clear Timeline Markers
            if (timelineBar) {
                 timelineBar.innerHTML = ''; // Clear all dynamically added markers
                 timelineBar.style.width = ''; // Reset timeline bar width inline style
            }


            // Clear Metrics Display (values, averages, computation, bar)
            if (ttSectionValues) { ttSectionValues.innerHTML = ''; }
            if (ttAverage) { ttAverage.textContent = '?'; } // Text content only, color reset by resetColors
            if (wtSectionValues) { wtSectionValues.innerHTML = ''; }
            if (wtAverage) { wtAverage.textContent = '?'; } // Text content only, color reset by resetColors
            if (cpuUtilizationBar) { cpuUtilizationBar.style.width = '0%'; } // Reset bar width
            if (cpuUtilizationPercentage) { cpuUtilizationPercentage.textContent = '?'; } // Text content only, color reset by resetColors
            if (cpuUtilizationComputation) { cpuUtilizationComputation.textContent = ''; } // Clear computation text


            // Reset all colors (text and body background) to default
            resetColors();


            // Reset selected algorithm state
            selectedAlgorithm = null;
            jobData = []; // Clear stored job data
            currentSchedule = null; // Clear stored schedule

            // Remove visual feedback (class and inline styles) from all algorithm buttons
            algoButtons.forEach(btn => {
                 btn.classList.remove('selected-algo');
                 // Inline background/color was cleared by resetColors or applyAlgorithmColor on new selection
            });


            console.log("Website reset.");
        } else {
            console.log("Reset cancelled.");
        }
    });


    // --- Help Button ---
    helpButton.addEventListener('click', () => {
        window.location.href = 'help.html'; // Redirect to the help page
    });


    // --- Initial setup: Select FCFS by default and apply its color ---
    // Find the FCFS button and simulate a click to select it initially
    const fcfsButton = document.querySelector('.algo-btn.fcfs');
     if (fcfsButton) {
         fcfsButton.click(); // This will trigger the event listener and apply color
     } else {
         // Fallback: if button not found, set state and apply color directly
         selectedAlgorithm = 'FCFS';
         // Manually add the selected class if click didn't work
         const defaultSelectedButton = document.querySelector('.algo-btn.fcfs');
         if (defaultSelectedButton) {
             defaultSelectedButton.classList.add('selected-algo');
         }
         applyAlgorithmColor(selectedAlgorithm);
     }

     // Scroll to top on page load
     window.scrollTo(0, 0);

});